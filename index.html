<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>TIIPS</title>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;600&display=swap" rel="stylesheet">
    <script src="https://polyfill.io/v3/polyfill.min.js?features=es6"></script>
    <script id="MathJax-script" async src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script>
        window.MathJax = {
            tex: {
                inlineMath: [['$', '$'], ['\\(', '\\)']],
                displayMath: [['$$', '$$'], ['\\[', '\\]']],
                processEscapes: true
            },
            options: {
                skipHtmlTags: ['script', 'noscript', 'style', 'textarea', 'pre']
            }
        };
    </script>
    <style>
        :root {
            --primary-color: #115e17;
            --secondary-color: #a2af9f;
            --background-color: #f8f9fa;
            --text-color: #2c3e50;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        body {
            font-family: 'Inter', sans-serif;
            line-height: 1.6;
            color: var(--text-color);
            background-color: var(--background-color);
        }
        
        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 2rem;
        }
        
        header {
            background-color: white;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            padding: 2rem 0;
            margin-bottom: 3rem;
        }
        
        .title {
            text-align: center;
            max-width: 800px;
            margin: 0 auto;
        }
        
        h1 {
            font-size: 2.5rem;
            color: var(--primary-color);
            margin-bottom: 1rem;
        }
        
        .subtitle {
            font-size: 1.2rem;
            color: #666;
            margin-bottom: 2rem;
        }
        
        .main-image {
            width: 100%;
            max-width: 800px;
            margin: 2rem auto;
            display: block;
            border-radius: 8px;
            box-shadow: 0 4px 8px rgba(0,0,0,0.1);
        }
        
        .section {
            background: white;
            padding: 2rem;
            border-radius: 8px;
            margin-bottom: 2rem;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        h2 {
            color: var(--primary-color);
            margin-bottom: 1rem;
            font-size: 1.8rem;
        }
        
        .abstract {
            font-size: 1.1rem;
            color: #444;
            margin-bottom: 2rem;
        }
        
        .button {
            display: inline-block;
            padding: 0.8rem 1.5rem;
            background-color: var(--secondary-color);
            color: white;
            text-decoration: none;
            border-radius: 4px;
            transition: background-color 0.3s;
            margin: 0.5rem;
        }
        
        .button:hover {
            background-color: #00618c;
        }
        
        .features {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(300px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .feature-card {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        footer {
            text-align: center;
            padding: 2rem 0;
            margin-top: 3rem;
            color: #666;
        }
        
        .paper-info {
            text-align: center;
            margin: 2rem 0;
            padding: 1rem;
            background: --background-color;
            border-radius: 8px;
        }
        
        .results-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
            gap: 2rem;
            margin: 2rem 0;
        }
        
        .result-image {
            width: 100%;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }
        
        .metric-card {
            background: white;
            padding: 1.5rem;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 4px rgba(0,0,0,0.05);
        }
        
        .metric-value {
            font-size: 2rem;
            font-weight: bold;
            color: var(--secondary-color);
        }
        
        .badge {
            display: inline-block;
            padding: 0.5rem 1rem;
            background: #6e7a6c;
            color: white;
            border-radius: 20px;
            font-size: 0.9rem;
            margin: 0.5rem;
        }
    </style>
</head>
<body>
    <header>
        <div class="container">
            <div style="position: absolute; top: 1rem; left: 1rem; display: flex; gap: 1rem;">
                <img src="images/Logo_TUC_de_CMYK (1).svg" alt="tuc" style="height: 85px;">
            </div>
            <div style="position: absolute; top: 1rem; right: 1rem; display: flex; gap: 1rem;">
                <img src="images/Full_logo (1).svg" alt="core" style="height: 100px;">
            </div>
            <div class="title">
                <h1>Transductively Informed Inductive Program Synthesis</h1>
                <div class="paper-info">
                    <a href="https://arxiv.org/abs/2505.14744" class="button">ðŸ“„ Read on arXiv</a>
                </div>
                <div style="margin-top: 2rem; text-align: center;">
                    <div style="display: inline-block;">
                        <div style="display: grid; grid-template-columns: repeat(3, minmax(200px, 1fr)); gap: 2rem;">
                            <div style="text-align: center;">
                                <p style="font-weight: 600; margin-bottom: 0.5rem; font-size: 1.1rem;">Janis Zenkner</p>
                                <p style="color: #666; font-size: 0.9rem; margin-bottom: 0.5rem;">Clausthal University of Technology</p>
                                <p style="color: #666; font-size: 0.9rem; font-family: monospace;">janis.zenkner@tu-clausthal.de</p>
                            </div>
                            <div style="text-align: center;">
                                <p style="font-weight: 600; margin-bottom: 0.5rem; font-size: 1.1rem;">Tobias Sesterhenn</p>
                                <p style="color: #666; font-size: 0.9rem; margin-bottom: 0.5rem;">Clausthal University of Technology</p>
                                <p style="color: #666; font-size: 0.9rem; font-family: monospace;">tobias.sesternhenn@tu-clausthal.de</p>
                            </div>
                            <div style="text-align: center;">
                                <p style="font-weight: 600; margin-bottom: 0.5rem; font-size: 1.1rem;">Christian Bartelt</p>
                                <p style="color: #666; font-size: 0.9rem; margin-bottom: 0.5rem;">Clausthal University of Technology</p>
                                <p style="color: #666; font-size: 0.9rem; font-family: monospace;">christian.bartelt@tu-clausthal.de</p>
                            </div>
                        </div>
                    </div>
                </div>
            </div>
        </div>
    </header>

    <main class="container">
        <section class="section">
            <h2>Abstract</h2>
            <div style="display: flex; gap: 2rem; align-items: flex-start; flex-wrap: wrap;">
                <div style="flex: 2; min-width: 300px;">
                    <p class="abstract">
                      Abstraction and reasoning in program synthesis has seen significant progress through both inductive and transductive paradigms. 
                      Inductive approaches generate a program or latent function from input-output examples, which can then be applied to new inputs. 
                      Transductive approaches directly predict output values for given inputs, effectively serving as the function themselves.
                      Current approaches combine inductive and transductive models via isolated ensembling, but they do not explicitly model the interaction between both paradigms. 
                      In this work, we introduce TIIPS, a novel framework that unifies transductive and inductive strategies by explicitly modeling their interactions through a cooperative mechanism: an inductive model generates programs, while a transductive model constrains, guides, and refines thesearch to improve synthesis accuracy and generalization.
                      We evaluate TIIPS on two widely studied program synthesis domains: string and list manipulation. 
                      Our results show that TIIPS solves more tasks and yields functions that more closely match optimal solutions in syntax and semantics, particularly in out-of-distribution settings, yielding state-of-the-art performance.
                      We believe that explicitly modeling the synergy between inductive and transductive reasoning opens promising avenues for general-purpose program synthesis and broader applications.    
                    <div style="flex: 1; min-width: 250px; background: #f8f9fa; padding: 1.5rem; border-radius: 8px;">
                    <h4 style="color: var(--primary-color); margin-bottom: 1rem;">Core Technologies</h4>
                    <ul style="list-style: none; padding: 0;">
                        <li style="margin-bottom: 0.8rem;">
                            <span style="font-weight: 600;">ðŸ’» Execution-guided Inductive Program Synthesis</span>
                        </li>
                        <li style="margin-bottom: 0.8rem;">
                            <span style="font-weight: 600;">ðŸ§­ Transductive Guidance</span>
                        </li>
                         <li style="margin-bottom: 0.8rem;">
                            <span style="font-weight: 600;">ðŸ¤– Transformer-Based Synthesis Model</span>
                        </li>
                        <li>
                            <span style="font-weight: 600;">ðŸŽ¯ Keywords</span>
                            <p style="font-size: 0.9rem; color: #666; margin-top: 0.2rem;">Program Synthesis, Transductive Guidance, Compositional Generalization, Execution-Guidance</p>
                        </li>
                    </ul>
                </div>
            </div>
        </section>

        <section class="section">
            <h2>Motivation</h2>
           <p>
                Synthesizing programs directly from input-output examples is inherently difficult due to the large search space and the absence of intermediate supervision. 
                To mitigate this, recent approaches employ <strong>explicit task decomposition</strong>: rather than synthesizing the full program in one step, the task is divided into smaller subtasks that are solved sequentially.
                This improves both interpretability and synthesis efficiency-but also introduces new challenges, especially when the predicted decompositions are misleading.
            </p>
            <p>
                Recent work 
                <a href="https://arxiv.org/abs/2411.02272" target="_blank" rel="noopener noreferrer">
                    (Li et al., 2024)
                </a> 
                demonstrates that PBE tasks can be addressed using both <strong>inductive methods</strong> (program synthesis) and <strong>transductive methods</strong> (predicting the output directly via neural networks), and that these strategies are highly complementary.
                The below figure illustrates this phenomenon: The left task can be addressed without trandsductive guidance using a loop while the denoising task on the right is easier to solve using transductive guidance.
                We hypothesize that this complementarity also holds at the <strong>subtask level</strong>: some subtasks are best handled through inductive synthesis, while others benefit from transductive guidance.
            </p>
            
            <h2>Programmnig by example</h2>
            Programming by Example (PBE) is a paradigm where users specify a program by providing a few input-output examples instead of writing code.
            The goal is to synthesize a program that is consistent with all provided examples-typically from a domain-specific language (DSL) designed for the task.
            <div style="background: white; padding: 1.5rem; border-radius: 8px; margin-top: 1rem; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <h4 style="color: var(--primary-color); margin-bottom: 1rem;">Illustrative PBE task</h4>
                <a href="https://lab42.global/arc/" target="_blank" rel="noopener noreferrer">
                    <div style="text-align: center;">
                        <img src="images/ARC11.png" alt="Inductive ARC Example" style="height: 200px;">
                        <img src="images/ARC21.png" alt="Transductive ARC Example" style="height: 200px;">
                    </div>  
                </a>
            </div>
        </section>
        <section class="section">
            <h2>Methodology</h2>
            We build on this insight by introducing a novel approach: Transductively Induced Iterative Program Synthesis (TIIPS).
            TIIPS leverages a powerful pre-trained Synthesizer to iteratively generate subprograms, which are executed on the task specification. 
            The results of each execution are used to update the specification, and the process is repeated for n steps.
            If this inductive procedure fails to solve the task entirely, a second model predicts an intermediate output-effectively proposing a decomposition. 
            This intermediate output defines a new PBE subtask, which is then passed back to the inductive procedure. 
            After solving the subtask, the remaining steps of the original task are completed without further transductive guidance.
        <!-- TIIPS Card -->
        <div class="feature-card" style="display: flex; flex-direction: column;">
            <div style="flex-grow: 1;">
                <h3>TIIPS</h3>
            </div>
             <div style="text-align: center;">
                <img src="images/image.png" alt="Pseudocode" style="height: 400px;">
            </div>  
        </div>
    </div>

        <div style="margin-bottom: 2rem;">
            <div style="background: white; padding: 1.5rem; border-radius: 8px; margin-top: 1.5rem; box-shadow: 0 2px 4px rgba(0,0,0,0.05);">
                <h4 style="color: var(--primary-color); margin-bottom: 1rem;">Evaluation Framework</h4>
                <p>Comprehensive evaluation across two program synthesis domains:</p>
                <ul style="list-style-type: none; padding-left: 1rem; margin: 1rem 0;">
                    <li>String manipulation</li>
                    <li>List manipulation</li>
                </ul>
            </div>
        </div>
    </section>
        <section class="section">
            <h2>Quantitative Results</h2>
            TIIPS consistently outperforms the baseline that uses no transductive guidance.
            This shows the importance of guidance, whether it is strict or sparse.
            TIIPS consistently improves the performance of decomposition-based synthesis by adaptively combining inductive and transductive methods.
            Specifically, on the <em>List manipulation</em> domain, TIIPS reaches <strong>30%</strong> task accuracy, outperforming ExeDec significantly. 
            Interestingly, the Baseline model performs similar to ExeDec on the List manipulation domain.
            While fully inductive baselines struggle in generalization tasks, they perform competitively in list operations-suggesting that transductive interventions should be applied selectively.
            <div style="text-align: center;">
                <img src="images/accuracy_barplot_deepcoder.svg" alt="acc_deepcoder" style="height: 400px;">
                <img src="images/accuracy_barplot_robustfill.svg" alt="acc_deepcoder" style="height: 400px;">
            </div>  
            
            <h2>Qualitative Results</h2>
            A key insight behind TIIPS is that transductive guidance can both help and hinder task-solving, depending on the context. 
            TIIPS outperforms ExeDec while requiring fewer guidance calls, especially in the list domain, where most guidance is only needed early in the synthesis process (Figure below). 
            This minimal and well-timed use of guidance allows TIIPS to maintain high performance with lower overhead, avoiding the pitfalls of rigid or excessive decomposition. 
            The results highlight the benefits of adaptive, domain-aware guidance policies, which improve both efficiency and robustness across tasks.
            
            <div style="text-align: center;">
                <img src="images/transductive_calls_barplot_deepcoder.svg" alt="acc_deepcoder" style="width: 400px;">
                <img src="images/transductive_calls_barplot_robustfill.svg" alt="acc_deepcoder" style="width: 400px;">
            </div>  
            
        </section>
    </main>

    <footer>
        <div class="container">
            <p>Â© 2025 CORE Research Team. All rights reserved.</p>
        </div>
    </footer>
</body>
</html> 
